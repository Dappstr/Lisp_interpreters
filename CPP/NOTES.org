#+TITLE: C++ Lisp Interpreter Notes

* Lexing

Create a token class which will contain an optional literal value, a token type, and methods to return the type, literal, and lexeme values.
Its constructor will take in a type, literal, and lexeme.

Optionally, overload the insertion operator to print the details of the token.

Create a class which will hold a string source, and have a current as well as starting position within it.
It will also have a vector of tokens member, along with a hash table (std::unordered_map) for the keywords.

Below are the methods, return value, and purpose:

| Method name    | Parameters                | Return value       | Purpose                                                                                                                                                                                                                                                                                                                |
|----------------+---------------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| scan_tokens    | N/A                       | std::vector<Token> | Call the scan_token method while is_at_end is false, as well as set the starting member to the current member                                                                                                                                                                                                          |
| scan_token     | N/A                       | void               | Get the current character and create a comparison/jump table depending on the character which will add a token to the current list for single character tokens, skip whitespace, and call the respective methods for number literals and identifiers                                                                   |
| is_at_end      | N/A                       | bool               | Return whether the current member is greater than or equal to the source size                                                                                                                                                                                                                                          |
| advance        | N/A                       | char               | Return the character in the source at the current position and increment the current member postfix                                                                                                                                                                                                                    |
| add_null_token | Token_Type                | void               | Call the add_token method supplying a type and a nullopt argument (since it has no literal value)                                                                                                                                                                                                                      |
| add_token      | Token_Type, literal value | void               | Get the substring starting from the start iterator and to the current iterator, and insert into the tokens member the given values                                                                                                                                                                                     |
| match          | char                      | bool               | Check if we are at the end of the string, if not check whether the current character is the same as the argued character, if it is, advance the current iterator, and return true, otherwise return false and do not increment the iterator                                                                            |
| peek           | N/A                       | char               | Check if we're at the end, if so, return the null terminator, otherwise return the current character in the source                                                                                                                                                                                                     |
| peek_next      | N/A                       | char               | If the current iterator + 1 is less than or greater than the source size, return the null terminator, otherwise return the character in the source at the current index + 1                                                                                                                                            |
| str            | N/A                       | void               | Use peek() to check while the current character is not equal to a quotation and while it's not at the end. If it is at end, print an error and return, otherwise advance, get the substring, and add the token                                                                                                         |
| number         | N/A                       | void               | Use peek() and isdigit to advance the current index, if you encounter a period, and the character after it is a digit, advance, and continue checking if there're numbers after. Once finished, make a substring from the start to the end, and convert it into a double/number, then add that token to the vector     |
| identifier     | N/A                       | void               | While peek() is alphanumeric, continue to advance the current iterator. Get a substring of text from start to current. Check if the given identifier is a keyword, if it is, call add_null_token and supply the value, otherwise call add_null_token and call add_null_token and supply the "type" argument IDENTIFIER |


* Parsing

We forward declare 2 types: Atom_Node and List_Node. The atom node type is responsible for holding the basic unit. List_Node will hold a list like structure such as an expression.

Optionally we make a type alias to a variant which can hold an Atom_Node, and a shared pointer to List_Node

For the Atom_Node class/struct, we declare a type enumerator which is used to distinguish whether the atom is a literal or identifier. We also have the atom store a variant for a string or double.
We also have an optional string to represent an identifier.

For the Atom_Node constructors, we declare one which takes in a double, which initializes the type enumerator to a literal, and the value (variant) to the double arg.
For the second, we have the constructor take in a string, and an optional boolean argument `is_identifier` which is equal to false. The member initializer list sets the Type enumerator to true if `is_identifier` is true, otherwise sets it to false. We also initialize the "value" variant.
We also have a condition for if is_identifier is true, set the identifier optional member to the argued string.

We also define two utility methods, one for returning whether the type is a literal, and the other for is an identifier.

Next, we create three methods, 2 for returning the value from the variant member, the third for returning a pointer to the identifier member (since it's an optional)

For the actual parser class, we take in a vector of Tokens and a current index member for keeping track of where we are.

| Method name | Parameters         | Return value          | Purpose                                                                                                                                                                                                                                                                                                                                                             |
|-------------+--------------------+-----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| parse       | N/A                | std::vector<AST_Node> | Create the initial vector for nodes, while !is_at_end continue to emplace_back expressions, then return the nodes vector                                                                                                                                                                                                                                            |
| expression  | N/A                | AST_Node              | Check if match method matches a left parenthesis, if so, return list() (an expression), otherwise return an atom                                                                                                                                                                                                                                                    |
| atom        | N/A                | AST_Node              | Checks if match() is a number, a string, or an identifier along with the math symbols. If it's a number, get the literal, check if it has a value, and then return an Atom_Node constructed with the value of the variant literal. If match is an identifier or math symbol, return an Atom_Node of the previous().lexeme() and "true" for the AST_Node constructor |
| list        | N/A                | shared_ptr            | Creates a vector of AST nodes, and while is_at_end() is false, and peek()'s type != a right parenthesis, emplace back the expression() method                                                                                                                                                                                                                       |
| advance     | N/A                | Token&                | Checks if is_at_end() is false, if it is, increment the current member and return the previous                                                                                                                                                                                                                                                                      |
| peek        | N/A                | Token&                | Returns the current token at the current index                                                                                                                                                                                                                                                                                                                      |
| previous    | N/A                | Token&                | Returns the token previous (current - 1) from the current one                                                                                                                                                                                                                                                                                                       |
| match       | Token_Type         | bool                  | Check if !is_at_end() and peek type is the argued type, if it is, advance and return true, else return false                                                                                                                                                                                                                                                        |
| is_at_end   | N/A                | bool                  | Return whether the current (through peek()) type is an EndofFile type                                                                                                                                                                                                                                                                                               |
| consume     | Token_Type, string | Token&                | If the token does not match, it throws a runtime error with a custom error message, making it easier to identify parsing issues.                                                                                                                                                                                                                                    |
|             |                    |                       |                                                                                                                                                                                                                                                                                                                                                                     |
